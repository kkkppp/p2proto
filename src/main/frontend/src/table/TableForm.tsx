import React, { useEffect, useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { motion } from 'framer-motion';
import {
    Button,
    Card,
    CardContent,
    Grid,
    TextField,
    Checkbox,
    FormControlLabel,
    RadioGroup,
    Radio,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    Typography,
} from '@mui/material';
import { BASE_PATH } from '@/lib/basePath';
import { getCsrfToken } from '@/lib/csrf';

/**
 * TableForm – renders an empty form for create or a filled form for edit using MUI components.
 */
export default function TableForm({
                                      mode = 'create',
                                      tableLabel = 'Record',
                                      tableName: tableNameProp,
                                      record = { fields: [] },
                                  }) {
    const navigate = useNavigate();
    const { tableName: urlTableName, recordId } = useParams();
    const tableName = tableNameProp || urlTableName;

    /* ------------------------------------------------------------------ */
    /*                               State                                */
    /* ------------------------------------------------------------------ */
    const [fields, setFields] = useState(() => record.fields.map((f) => ({ ...f })));
    const [confirm, setConfirm] = useState({});
    const [loading, setLoading] = useState(false);
    const [errors, setErrors] = useState({});

    // when new record arrives (async fetch) sync local state
    useEffect(() => {
        setFields(record.fields.map((f) => ({ ...f })));
    }, [record]);

    /* ------------------------------------------------------------------ */
    /*                               Helpers                              */
    /* ------------------------------------------------------------------ */
    const handleChange = (idx, newValue) =>
        setFields((prev) => {
            const next = [...prev];
            next[idx] = { ...next[idx], value: newValue };
            return next;
        });

    const handleConfirmChange = (name, value) => setConfirm((c) => ({ ...c, [name]: value }));

    const validatePasswords = () => {
        const invalid = {};
        fields.forEach((f) => {
            if (f.type === 'PASSWORD' && confirm[f.name] !== (f.value ?? '')) {
                invalid[f.name] = ['Passwords do not match.'];
            }
        });
        setErrors(invalid);
        return Object.keys(invalid).length === 0;
    };

    const buildPayload = () => ({
        ...record,
        fields: fields.map(({ name, type, required, autoGenerated, value }) => ({
            name,
            type,
            required,
            autoGenerated,
            value,
        })),
    });

    /* ------------------------------------------------------------------ */
    /*                              Submit                                */
    /* ------------------------------------------------------------------ */
    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!validatePasswords()) return;

        const token = getCsrfToken();

        const url =
            mode === 'create'
                ? `${BASE_PATH}/table/${tableName}/create`
                : `${BASE_PATH}/table/${tableName}/${recordId}/edit`;
        try {
            setLoading(true);
            const res = await fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-XSRF-TOKEN': token ?? ''
                },
                credentials: 'include',
                body: JSON.stringify(buildPayload()),
            });
            if (!res.ok) throw new Error(`Server responded ${res.status}`);
            navigate(`/table/${tableName}`);
        } catch (err) {
            console.error(err);
            alert('Could not save.');
        } finally {
            setLoading(false);
        }
    };

    /* ------------------------------------------------------------------ */
    /*                             Renderers                              */
    /* ------------------------------------------------------------------ */
    const renderInput = (field, idx) => {
        if (field.autoGenerated) {
            return (
                <TextField
                    fullWidth
                    id={field.name}
                    label={field.label}
                    value={field.value}
                    InputProps={{ readOnly: true }}
                    disabled
                />
            );
        }

        switch (field.type) {
            case 'PASSWORD': {
                const mask = mode === 'edit' ? '********' : '';
                return (
                    <>
                        <TextField
                            fullWidth
                            id={field.name}
                            label={field.label}
                            type="password"
                            required={field.required}
                            value={field.value ?? mask}
                            onChange={(e) => handleChange(idx, e.target.value)}
                            error={Boolean(errors[field.name])}
                            helperText={errors[field.name]?.[0]}
                        />
                        <TextField
                            sx={{ mt: 2 }}
                            fullWidth
                            id={`${field.name}Confirm`}
                            label={`Confirm ${field.label}`}
                            type="password"
                            required={field.required}
                            value={confirm[field.name] ?? mask}
                            onChange={(e) => handleConfirmChange(field.name, e.target.value)}
                        />
                    </>
                );
            }

            case 'EMAIL':
                return (
                    <TextField
                        fullWidth
                        id={field.name}
                        label={field.label}
                        type="email"
                        required={field.required}
                        value={field.value ?? ''}
                        onChange={(e) => handleChange(idx, e.target.value)}
                    />
                );

            case 'SELECT':
                return (
                    <FormControl fullWidth required={field.required}>
                        <InputLabel id={`${field.name}-label`}>{field.label}</InputLabel>
                        <Select
                            labelId={`${field.name}-label`}
                            id={field.name}
                            value={field.value ?? ''}
                            label={field.label}
                            onChange={(e) => handleChange(idx, e.target.value)}
                        >
                            <MenuItem value="">
                                <em>None</em>
                            </MenuItem>
                            {field.options?.map((opt) => (
                                <MenuItem key={opt} value={opt}>
                                    {opt}
                                </MenuItem>
                            ))}
                        </Select>
                    </FormControl>
                );

            case 'RADIO':
                return (
                    <FormControl component="fieldset">
                        <Typography sx={{ mb: 1 }}>{field.label}</Typography>
                        <RadioGroup
                            row
                            name={field.name}
                            value={field.value ?? ''}
                            onChange={(e) => handleChange(idx, e.target.value)}
                        >
                            {field.options?.map((opt) => (
                                <FormControlLabel key={opt} value={opt} control={<Radio />} label={opt} />
                            ))}
                        </RadioGroup>
                    </FormControl>
                );

            case 'CHECKBOX':
                return (
                    <FormControlLabel
                        control={
                            <Checkbox
                                checked={Boolean(field.value)}
                                onChange={(e) => handleChange(idx, e.target.checked)}
                            />
                        }
                        label={field.label}
                    />
                );

            default:
                return (
                    <TextField
                        fullWidth
                        id={field.name}
                        label={field.label}
                        required={field.required}
                        value={field.value ?? ''}
                        onChange={(e) => handleChange(idx, e.target.value)}
                    />
                );
        }
    };

    /* ------------------------------------------------------------------ */
    /*                                UI                                  */
    /* ------------------------------------------------------------------ */
    return (
        <Card sx={{ maxWidth: 720, mx: 'auto', mt: 3, position: 'relative' }}>
            <CardContent>
                <Typography variant="h5" gutterBottom>
                    {mode === 'create' ? `Create New ${tableLabel}` : `Edit ${tableLabel}`}
                </Typography>

                <form onSubmit={handleSubmit} noValidate>
                    <Grid container spacing={2}>
                        {fields.map((field, idx) => (
                            <Grid item xs={12} sm={6} key={field.name}>
                                {renderInput(field, idx)}
                            </Grid>
                        ))}
                    </Grid>

                    <Grid container spacing={2} sx={{ mt: 3 }}>
                        <Grid item>
                            <Button type="submit" variant="contained" disabled={loading}>
                                Finish
                            </Button>
                        </Grid>
                        <Grid item>
                            <Button variant="outlined" onClick={() => navigate(`/table/${tableName}`)}>
                                Cancel
                            </Button>
                        </Grid>
                    </Grid>
                </form>
            </CardContent>

            {loading && (
                <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    style={{
                        position: 'absolute',
                        inset: 0,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        backdropFilter: 'blur(2px)',
                        background: 'rgba(255,255,255,0.6)',
                        borderRadius: 8,
                    }}
                >
                    <Typography>Submitting…</Typography>
                </motion.div>
            )}
        </Card>
    );
}
