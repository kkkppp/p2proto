import React, { useState } from "react";
import Button from '@mui/material/Button';
import Card from '@mui/material/Card';
import CardContent from '@mui/material/CardContent';
import { motion } from "framer-motion";
import { useNavigate, useParams } from "react-router-dom";

/**
 * TableForm – renders an empty form for create or a filled form for edit,
 * and POSTs back to the SAME path that rendered it (Spring MVC style).
 */
export default function TableForm({
                                      mode = "create", // "create" | "edit" (injected via <Route>)
                                      tableLabel = "Record", // optional human label
                                      csrfToken,
                                      // If you render <TableForm tableName="x" /> manually you can still pass tableName.
                                      tableName: tableNameProp,
                                      record = { fields: [] },
                                  }) {
    const navigate = useNavigate();
    const { tableName: urlTableName, recordId } = useParams();
    const tableName = tableNameProp || urlTableName;

    /* ----------------------------- State ----------------------------- */
    const [fields, setFields] = useState(() => record.fields.map((f) => ({ ...f })));
    const [confirm, setConfirm] = useState({});
    const [loading, setLoading] = useState(false);
    const [errors, setErrors] = useState({});

    /* ---------------------------- Helpers ---------------------------- */
    const handleChange = (idx, newValue) => {
        setFields((prev) => {
            const next = [...prev];
            next[idx] = { ...next[idx], value: newValue };
            return next;
        });
    };

    const handleConfirmChange = (name, value) => setConfirm((c) => ({ ...c, [name]: value }));

    const validatePasswords = () => {
        const invalid = {};
        fields.forEach((f) => {
            if (f.type === "PASSWORD" && confirm[f.name] !== (f.value ?? "")) {
                invalid[f.name] = ["Passwords do not match."];
            }
        });
        setErrors(invalid);
        return Object.keys(invalid).length === 0;
    };

    const buildPayload = () => ({
        ...record,
        fields: fields.map(({ name, type, required, autoGenerated, value }) => ({
            name,
            type,
            required,
            autoGenerated,
            value,
        })),
    });

    /* --------------------------- Submission -------------------------- */
    const handleSubmit = async (e) => {
        e.preventDefault();
        if (!validatePasswords()) return;

        // POST back to the *same* MVC controller path that rendered the form
        const url =
            mode === "create"
                ? `/table/${tableName}/create` // e.g. /table/user/create
                : `/table/${tableName}/${recordId}/edit`; // e.g. /table/user/42/edit

        try {
            setLoading(true);
            const res = await fetch(url, {
                method: "POST", // same path, different HTTP method from the GET that delivered HTML/JSON
                headers: {
                    "Content-Type": "application/json",
                    "X-CSRF-TOKEN": csrfToken,
                },
                body: JSON.stringify(buildPayload()),
            });

            if (!res.ok) throw new Error(`Server responded ${res.status}`);
            navigate(`/table/${tableName}`); // go back to list
        } catch (err) {
            console.error(err);
            alert("Could not save. Check console for details.");
        } finally {
            setLoading(false);
        }
    };

    /* --------------------------- UI helpers -------------------------- */
    const renderFieldInput = (field, idx) => {
        if (field.autoGenerated) {
            return mode === "edit" ? (
                <input
                    id={field.name}
                    className="form-control bg-gray-100 cursor-not-allowed"
                    readOnly
                    value={field.value}
                />
            ) : null; // hidden on create
        }

        switch (field.type) {
            case "PASSWORD": {
                const mask = mode === "edit" ? "********" : "";
                return (
                    <>
                        <input
                            type="password"
                            id={field.name}
                            className="form-control"
                            required={field.required}
                            value={field.value ?? mask}
                            onChange={(e) => handleChange(idx, e.target.value)}
                        />
                        <label htmlFor={`${field.name}Confirm`} className="mt-4 block text-sm font-medium text-muted-foreground">
                            Confirm {field.label}
                        </label>
                        <input
                            type="password"
                            id={`${field.name}Confirm`}
                            className="form-control"
                            required={field.required}
                            value={confirm[field.name] ?? mask}
                            onChange={(e) => handleConfirmChange(field.name, e.target.value)}
                        />
                    </>
                );
            }

            case "EMAIL":
                return (
                    <input
                        type="email"
                        id={field.name}
                        className="form-control"
                        required={field.required}
                        value={field.value ?? ""}
                        onChange={(e) => handleChange(idx, e.target.value)}
                    />
                );

            case "SELECT":
                return (
                    <select
                        id={field.name}
                        className="form-control"
                        required={field.required}
                        value={field.value ?? ""}
                        onChange={(e) => handleChange(idx, e.target.value)}
                    >
                        <option value="">-- Select --</option>
                        {field.options?.map((opt) => (
                            <option key={opt} value={opt}>
                                {opt}
                            </option>
                        ))}
                    </select>
                );

            case "RADIO":
                return (
                    <div className="flex flex-wrap gap-4">
                        {field.options?.map((opt) => (
                            <label key={opt} className="flex items-center gap-1">
                                <input
                                    type="radio"
                                    name={field.name}
                                    value={opt}
                                    checked={field.value === opt}
                                    required={field.required}
                                    onChange={(e) => handleChange(idx, e.target.value)}
                                />
                                {opt}
                            </label>
                        ))}
                    </div>
                );

            case "CHECKBOX":
                return (
                    <input
                        type="checkbox"
                        id={field.name}
                        checked={Boolean(field.value)}
                        required={field.required}
                        onChange={(e) => handleChange(idx, e.target.checked)}
                    />
                );

            default:
                return (
                    <input
                        id={field.name}
                        className="form-control"
                        required={field.required}
                        value={field.value ?? ""}
                        onChange={(e) => handleChange(idx, e.target.value)}
                    />
                );
        }
    };

    /* ------------------------------ Render ------------------------------ */
    return (
        <Card className="mx-auto w-full max-w-2xl shadow-xl rounded-2xl p-6 relative">
            <CardContent>
                <h2 className="text-2xl font-semibold mb-6">
                    {mode === "create" ? `Create New ${tableLabel}` : `Edit ${tableLabel}`}
                </h2>

                <form className="space-y-6" aria-labelledby="createUserForm" onSubmit={handleSubmit}>
                    {fields.map((field, idx) => (
                        <div key={field.name} className="form-group">
                            {/* label (skip for hidden autogenerated on create) */}
                            {!field.autoGenerated || mode === "edit" ? (
                                <label htmlFor={field.name} className="mb-1 block text-sm font-medium text-muted-foreground">
                                    {field.label}:
                                </label>
                            ) : null}

                            {/* input */}
                            {renderFieldInput(field, idx)}

                            {/* errors */}
                            {(errors[field.name] || field.errors)?.length ? (
                                <div className="text-destructive mt-2 space-y-1">
                                    {(errors[field.name] || field.errors).map((e) => (
                                        <p key={e}>{e}</p>
                                    ))}
                                </div>
                            ) : null}
                        </div>
                    ))}

                    {/* actions */}
                    <div className="flex items-center gap-4 pt-4">
                        <Button type="submit" disabled={loading} className="shadow-sm">
                            Finish
                        </Button>
                        <Button type="button" variant="secondary" onClick={() => navigate(`/table/${tableName}`)}>
                            Cancel
                        </Button>
                    </div>
                </form>

                {/* loading overlay */}
                {loading && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="absolute inset-0 flex items-center justify-center bg-background/70 backdrop-blur rounded-2xl"
                    >
                        <p className="loading animate-pulse text-lg font-medium">Submitting...</p>
                    </motion.div>
                )}
            </CardContent>
        </Card>
    );
}
