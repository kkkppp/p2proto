package org.p2proto.repository;

import lombok.extern.slf4j.Slf4j;
import org.p2proto.ddl.Domain;
import org.p2proto.dto.TableMetadata;
import org.p2proto.dto.ColumnMetaData;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.security.crypto.bcrypt.BCrypt;

import java.text.DateFormat;
import java.text.ParseException;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Basic CRUD repository that uses TableMetadata to dynamically build
 * SQL statements for a specific table.
 */
@Slf4j
public class TableMetadataCrudRepository {

    public static final String PASSWORD_MASK = "********";
    private final JdbcTemplate jdbcTemplate;
    private final TableMetadata tableMetadata;
    private final String primaryKeyColumn;

    /**
     * @param jdbcTemplate     Spring's JdbcTemplate for DB operations
     * @param tableMetadata    Metadata for the target table (physical name + columns)
     * @param primaryKeyColumn The name of the primary key column in the table
     */
    public TableMetadataCrudRepository(JdbcTemplate jdbcTemplate,
                                       TableMetadata tableMetadata,
                                       String primaryKeyColumn) {
        this.jdbcTemplate = jdbcTemplate;
        this.tableMetadata = tableMetadata;
        this.primaryKeyColumn = primaryKeyColumn;
    }

    /**
     * Retrieves all rows from the table, returning each row as a Map of column->value
     */
    public List<Map<String, Object>> findAll() {
        String sql = tableMetadata.generateSelectStatement();
        return jdbcTemplate.queryForList(sql);
    }

    /**
     * Retrieves a single row by primary key.
     *
     * @param pkValue The primary key value (e.g., UUID or Long, etc.)
     * @return A Map of column->value for the row, or null if none found
     */
    public Map<String, Object> findById(Integer pkValue) {
        ColumnMetaData primaryKeyMeta = tableMetadata.getColumns().stream()
                .filter(column -> column.getName().equals(primaryKeyColumn))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Primary key column not found: " + primaryKeyColumn));

        String whereClause = primaryKeyMeta.generateWherePart();
        String sql = tableMetadata.generateSelectStatement() + " WHERE " + whereClause;

        try {
            return jdbcTemplate.queryForMap(sql, pkValue);
        } catch (EmptyResultDataAccessException e) {
            // No row found
            return null;
        }
    }

    /**
     * Creates a map of column name -> converted value. This filters out any
     * columns not found in tableMetadata, and converts the values via getDBValue.
     *
     * @throws IllegalArgumentException if no valid columns remain.
     */
    private Map<String, Object> prepareAndFilterRowData(Map<String, Object> rowData) {
        // Create a mapping from column name to its metadata for quick lookup
        Map<String, ColumnMetaData> columnsByName = tableMetadata.getColumns()
                .stream()
                .filter(column -> ! column.getAutoGenerated() )
                .collect(Collectors.toMap(org.p2proto.dto.ColumnMetaData::getName, Function.identity()));

        Map<String, Object> filteredData = new HashMap<>();

        for (Map.Entry<String, Object> entry : rowData.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();
            if (!columnsByName.containsKey(key)) continue;
            ColumnMetaData meta = columnsByName.get(key);
            if (meta.getDomain().equals(Domain.PASSWORD) && PASSWORD_MASK.equals(value)) continue;
            Object dbValue = getDBValue(meta.getDomain(), value);
            if (dbValue == null) continue;
            filteredData.put(key, dbValue);
        }

        if (filteredData.isEmpty()) {
            throw new IllegalArgumentException("No valid columns found in rowData.");
        }

        return filteredData;
    }

    /**
     * Inserts a new row. The row data should map column names to their values.
     * Only columns that exist in TableMetadata will be included in the insert.
     *
     * @param rowData A Map of column->value for the new record
     * @return number of rows affected (should be 1 if successful)
     */

    public int insert(Map<String, Object> rowData) {
        // Reuse the helper method
        Map<String, Object> filteredData = prepareAndFilterRowData(rowData);

        // Build the column list and placeholders for the INSERT statement
        List<String> columns = new ArrayList<>(filteredData.keySet());
        String colList = String.join(", ", columns);
        String placeholders = columns.stream()
                .map(c -> "?")
                .collect(Collectors.joining(", "));

        String sql = String.format("INSERT INTO %s (%s) VALUES (%s)",
                tableMetadata.getTableName(),
                colList,
                placeholders);

        // Extract values in the same column order
        Object[] values = columns.stream()
                .map(filteredData::get)
                .toArray();

        return jdbcTemplate.update(sql, values);
    }

    /**
     * Updates an existing row identified by the primary key. The row data
     * should contain column->value pairs for what is to be updated.
     *
     * @param pkValue The primary key value (e.g. UUID or Long)
     * @param rowData The columns/values to update
     * @return number of rows affected (should be 1 if successful)
     */
    public int update(Integer pkValue, Map<String, Object> rowData) {
        // Reuse the helper method
        Map<String, Object> filteredData = prepareAndFilterRowData(rowData);

        // Build the "SET col = ?" portion
        List<String> assignments = new ArrayList<>();
        List<Object> values = new ArrayList<>();
        for (Map.Entry<String, Object> entry : filteredData.entrySet()) {
            assignments.add(entry.getKey() + " = ?");
            values.add(entry.getValue());
        }

        // Add the PK value at the end
        values.add(pkValue);

        String setClause = String.join(", ", assignments);

        // Find PK column metadata (assuming 'primaryKeyColumn' is known)
        ColumnMetaData primaryKeyMeta = tableMetadata.getColumns().stream()
                .filter(c -> c.getName().equals(primaryKeyColumn))
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Primary key column not found!"));

        String sql = String.format("UPDATE %s SET %s WHERE %s",
                tableMetadata.getTableName(),
                setClause,
                primaryKeyMeta.generateWherePart());

        return jdbcTemplate.update(sql, values.toArray());
    }

    /**
     * Converts a given raw value to the appropriate type for DB storage.
     * This logic is shared by both insert() and update().
     */
    private Object getDBValue(Domain dataType, Object value) {
        if (value == null) {
            return null;
        }
        if (Domain.BOOLEAN.equals(dataType)) {
            // If it's a string, trim and handle empty as null
            if (value instanceof String) {
                String strVal = ((String) value).trim();
                if (strVal.isEmpty()) {
                    return null;
                }
                return Boolean.valueOf(strVal);
            }
            // If it's already a Boolean or something else,
            // just convert via toString() as a fallback
            return Boolean.valueOf(value.toString());
        } else if (Domain.PASSWORD.equals(dataType)) {
            return BCrypt.hashpw(value.toString(), BCrypt.gensalt(10));
        } else if (Domain.DATE.equals(dataType) || Domain.DATETIME.equals(dataType)) {
            if (value instanceof String stringValue) {
                if (stringValue.isEmpty()) {
                    value = null;
                } else {
                    try {
                        value = DateFormat.getDateInstance().parse(stringValue);
                    } catch (ParseException e) {
                        log.error(e.getLocalizedMessage());
                        value = null;
                    }
                }
            }
        }

        // For other types, return as-is (or add more cases if needed)
        return value;
    }

    /**
     * Deletes a row identified by the primary key.
     *
     * @param pkValue The primary key value
     * @return number of rows affected (should be 1 if successful)
     */
    public int delete(Integer pkValue) {
        String sql = String.format("DELETE FROM %s WHERE %s = ?",
                tableMetadata.getTableName(),
                primaryKeyColumn);

        return jdbcTemplate.update(sql, pkValue);
    }

    public void save(Map<String, Object> recordData) {
        String idValue = recordData.get("id").toString();
        Integer id = null;
        if (! (idValue == null || idValue.isEmpty())) {
            id = Integer.valueOf(idValue);
        }
        if (id == null || id.toString().isEmpty() ) {
            insert(recordData);
        }
        else {
            update(id, recordData);
        }
    }
}
